// 비트연산자 &, | , ^, ~
// 용도: 이미지 프로세싱 분야에서 사용
package ch04;

public class Test13 {
  public static void main(String[] args) {
    // & => 둘 다 1일 때만 결과는 1이다
    // | -> 둘 중 한 개라도 1이면 결과는 1
    // 1(true), 0(false)로 간주
    
    int a = 0xca; // 0000 0000 0000 0000 0000 0000 1100 1010
    int b = 0x66; // 0000 0000 0000 0000 0000 0000 0110 0110
    System.out.println(a & b); //0x42 = 66
    //                  0000 0000   0000  0000 0000 0000   0100  0010
    //                                                      64    2
       
    System.out.println(a | b); //0xee = 238
    //                                                     1110 1110
    //                                                    2 4 8 32 64 128       
    //                                                                238   
    
    // ^ => 두 개의 비트가 다르면 결과는 1이다
    System.out.println(a ^ b); //0xac = 172
    //                                                      1010  1100
    
    // ~ => 모든 비트를 반대 값으로 바꾼다
    System.out.println(~a);   //0xffffff35  = -203
    //                     1111 1111 1111 1111 1111 1111 0011 0101 (맨 앞이 1이면 음수)
    // 양수로 값 계산        0000 0000 0000 0000 0000 0000 1100 1011
    
    
    
    // &활용 : 특정 값을 차단하고 특정 값만 통과시킬 때
    int data = 0b1111_1001_0111_1111;
//    System.out.println(data & 0b0000_1111_1100_0000);이 값을 그대로 출력하면 10진수 값 출력됨
    System.out.println(Integer.toBinaryString(data & 0b0000_1111_1100_0000));
//    1111 1001 0111 1111
//    0000 1111 1100 0000
//    0으로 된 것은 다 차단
//    0000 1001 0100 0000
    
    //예) 그림의 한 픽셀에서 빨간색을 제거하고 싶다
    int pixcel = 0x003f4478; // 각 바이트 값이 "00RRGGBB"라고 가정
    System.out.println(Integer.toBinaryString(pixcel & 0x0000ffff));
    // Pixel  : 00000000_00111111_01000100_01111000
    //  a   & : 00000000_00000000_11111111_11111111
    //  a     : 00000000_00000000_01000100_01111000
    
    //예) 그림의 파란색을 강화하고 싶다
   // | OR 연산자 사용
      
  }
}
